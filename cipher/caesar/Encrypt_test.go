// ********RoostGPT********
/*
Test generated by RoostGPT for test testingGoCoverage using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=Encrypt_f4afecbcd9
ROOST_METHOD_SIG_HASH=Encrypt_d9cc5e858a

================================VULNERABILITIES================================
Vulnerability: Inefficient Memory Usage
Issue: The current implementation of the Encrypt function uses append inside a loop, which can lead to inefficient memory usage as the underlying array of the slice is reallocated multiple times.
Solution: Preallocate the capacity of the outputBuffer slice to the length of the input string to avoid reallocation. You can do this by using make function: outputBuffer := make([]byte, 0, len(input)).

Vulnerability: Lack of Input Validation
Issue: The function does not validate the input string. It only operates correctly on ASCII strings. For non-ASCII strings, the behavior is undefined.
Solution: Before performing operations on the input string, check if it is a valid ASCII string. If not, return an error or handle it appropriately.

================================================================================
Scenario 1: Basic encryption with valid inputs

Details:
    Description: This test is meant to check the basic functionality of the "Encrypt" function. It will test if the function is able to encrypt a string correctly using a provided key.
Execution:
    Arrange: We need a string and a key for encryption. For instance, the string can be "HELLO" and the key can be 3.
    Act: Invoke the "Encrypt" function with the string "HELLO" and key as 3.
    Assert: Use Go's testing facilities to verify that the encrypted string is "KHOOR".
Validation:
    The expected output "KHOOR" is obtained by shifting each letter in "HELLO" 3 places to the right in the alphabet. This test is important to confirm that the function can correctly encrypt a string with a provided key.

Scenario 2: Encryption with a negative key

Details:
    Description: This test is meant to check if the "Encrypt" function can handle negative keys. It will test if the function is able to encrypt a string correctly using a negative key.
Execution:
    Arrange: We need a string and a key for encryption. For instance, the string can be "HELLO" and the key can be -3.
    Act: Invoke the "Encrypt" function with the string "HELLO" and key as -3.
    Assert: Use Go's testing facilities to verify that the encrypted string is "EBIIL".
Validation:
    The expected output "EBIIL" is obtained by shifting each letter in "HELLO" 3 places to the left in the alphabet. This test is important to confirm that the function can handle negative keys.

Scenario 3: Encryption with non-alphabetic characters

Details:
    Description: This test is meant to check if the "Encrypt" function can handle non-alphabetic characters. It will test if the function leaves non-alphabetic characters untouched.
Execution:
    Arrange: We need a string and a key for encryption. For instance, the string can be "HELLO, WORLD!" and the key can be 3.
    Act: Invoke the "Encrypt" function with the string "HELLO, WORLD!" and key as 3.
    Assert: Use Go's testing facilities to verify that the encrypted string is "KHOOR, ZRUOG!".
Validation:
    The expected output "KHOOR, ZRUOG!" is obtained by shifting each letter in "HELLO, WORLD!" 3 places to the right in the alphabet, leaving non-alphabetic characters untouched. This test is important to confirm that the function can handle non-alphabetic characters.

Scenario 4: Encryption with a key of zero

Details:
    Description: This test is meant to check if the "Encrypt" function can handle a key of zero. It will test if the function leaves the string untouched when the key is zero.
Execution:
    Arrange: We need a string and a key for encryption. For instance, the string can be "HELLO" and the key can be 0.
    Act: Invoke the "Encrypt" function with the string "HELLO" and key as 0.
    Assert: Use Go's testing facilities to verify that the encrypted string is "HELLO".
Validation:
    The expected output "HELLO" is the same as the input string, as shifting a letter 0 places in the alphabet leaves it unchanged. This test is important to confirm that the function can handle a key of zero.

*/

// ********RoostGPT********
package caesar

import (
	"testing"
)

func TestEncrypt(t *testing.T) {
    tests := []struct {
        name   string
        input  string
        key    int
        want   string
    }{
        {
            name:   "Basic encryption with valid inputs",
            input:  "HELLO",
            key:    3,
            want:   "KHOOR",
        },
        {
            name:   "Encryption with a negative key",
            input:  "HELLO",
            key:    -3,
            want:   "EBIIL",
        },
        {
            name:   "Encryption with non-alphabetic characters",
            input:  "HELLO, WORLD!",
            key:    3,
            want:   "KHOOR, ZRUOG!",
        },
        {
            name:   "Encryption with a key of zero",
            input:  "HELLO",
            key:    0,
            want:   "HELLO",
        },
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            got := Encrypt(tc.input, tc.key)
            if got != tc.want {
                t.Errorf("Encrypt(%q, %d) = %q; want %q", tc.input, tc.key, got, tc.want)
            }
        })
    }
}
